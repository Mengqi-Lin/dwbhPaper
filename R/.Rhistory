V <- c()
R <- c()
for(i in 1:length(pi0_g)) {
pi0 = pi0_g[i]
mu1 = mu1_g[i]
n = n_g[i]
t = lfdr.inverse_mvgauss(c, pi0, mu1, side = side)
V[i] = n*pi0*t
R[i] = V[i] + n*(1-pi0)*nonnull.cdf_mvgauss(t, mu1)
}
return(sum(V)/sum(R))
}
lambda_alpha <- vecbinsolv(zf = alpha, fun = mFDR , tlo = 0, thi = 1, nits = 30)
w <- c()
t <- c()
for(i in 1:length(n_g)) {
t[i] <- lfdr.inverse_mvgauss(lambda_alpha, pi0 = pi0_g[i], mu1 = mu1_g[i], side = side)
}
if(pi0Est) {
t <- t/sum(t*pi0_g*pi_g)
} else{
t <- t/mean(t)
}
for(i in 1:length(n_g)) {
w <- c(w, rep(t[i], n_g[i]))
}
return(lambda_alpha)
}
oracle.weights_mvgauss(0.05, 1000, 0.9, 2, T, side = "one")
nonnull.cdf_mvgauss <- function(p, mu1, side) {
if(side == "one") {
pnorm(qnorm(1-p) - mu1,lower.tail = F)
} else if(side == "two") {
pnorm((qnorm(1-p/2) - mu1),lower.tail = F) + pnorm(qnorm(1-p/2))
}
}
nonnull.cdf_mvgauss <- function(p, mu1, side) {
if(side == "one") {
pnorm(qnorm(1-p) - mu1,lower.tail = F)
} else if(side == "two") {
pnorm((qnorm(1-p/2) - mu1),lower.tail = F) + pnorm(qnorm(1-p/2))
}
}
nonnull.cdf_mvgauss <- function(p, mu1, side) {
if(side == "one") {
pnorm(qnorm(1-p) - mu1,lower.tail = F)
} else if(side == "two") {
pnorm((qnorm(1-p/2) - mu1),lower.tail = F) + pnorm(qnorm(1-p/2))
}
}
nonnull.cdf_mvgauss1 <- function(p){
nonnull.cdf_mvgauss(p, 3, "one")
}
plot(nonnull.cdf_mvgauss1)
nonnull.cdf_mvgauss2 <- function(p){
nonnull.cdf_mvgauss(p, 3, "two")
}
plot(nonnull.cdf_mvgauss2)
nonnull.cdf_mvgauss <- function(p, mu1, side) {
if(side == "one") {
pnorm(qnorm(1-p) - mu1,lower.tail = F)
} else if(side == "two") {
pnorm((qnorm(1-p/2) - mu1),lower.tail = F) + pnorm(qnorm(1-p/2)+mu1)
}
}
nonnull.cdf_mvgauss2 <- function(p){
nonnull.cdf_mvgauss(p, 3, "two")
}
plot(nonnull.cdf_mvgauss2)
nonnull.cdf_mvgauss1 <- function(p){
nonnull.cdf_mvgauss(p, 3, "one")
}
plot(nonnull.cdf_mvgauss1)
oracle.weights_mvgauss <- function(alpha, n_g, pi0_g, mu1_g, pi0Est = T, side) {
pi_g <- n_g/sum(n_g)
#lambda_alpha <- solve.mFDR(alpha, n_g, pi0_g, mu1_g)
mFDR <- function(c) {
V <- c()
R <- c()
for(i in 1:length(pi0_g)) {
pi0 = pi0_g[i]
mu1 = mu1_g[i]
n = n_g[i]
t = lfdr.inverse_mvgauss(c, pi0, mu1, side = side)
V[i] = n*pi0*t
R[i] = V[i] + n*(1-pi0)*nonnull.cdf_mvgauss(t, mu1, side)
}
return(sum(V)/sum(R))
}
lambda_alpha <- vecbinsolv(zf = alpha, fun = mFDR , tlo = 0, thi = 1, nits = 30)
w <- c()
t <- c()
for(i in 1:length(n_g)) {
t[i] <- lfdr.inverse_mvgauss(lambda_alpha, pi0 = pi0_g[i], mu1 = mu1_g[i], side = side)
}
if(pi0Est) {
t <- t/sum(t*pi0_g*pi_g)
} else{
t <- t/mean(t)
}
for(i in 1:length(n_g)) {
w <- c(w, rep(t[i], n_g[i]))
}
return(lambda_alpha, )
}
oracle.weights_mvgauss <- function(alpha, n_g, pi0_g, mu1_g, pi0Est = T, side) {
pi_g <- n_g/sum(n_g)
#lambda_alpha <- solve.mFDR(alpha, n_g, pi0_g, mu1_g)
mFDR <- function(c) {
V <- c()
R <- c()
for(i in 1:length(pi0_g)) {
pi0 = pi0_g[i]
mu1 = mu1_g[i]
n = n_g[i]
t = lfdr.inverse_mvgauss(c, pi0, mu1, side = side)
V[i] = n*pi0*t
R[i] = V[i] + n*(1-pi0)*nonnull.cdf_mvgauss(t, mu1, side)
}
return(sum(V)/sum(R))
}
lambda_alpha <- vecbinsolv(zf = alpha, fun = mFDR , tlo = 0, thi = 1, nits = 30)
w <- c()
t <- c()
for(i in 1:length(n_g)) {
t[i] <- lfdr.inverse_mvgauss(lambda_alpha, pi0 = pi0_g[i], mu1 = mu1_g[i], side = side)
}
if(pi0Est) {
t <- t/sum(t*pi0_g*pi_g)
} else{
t <- t/mean(t)
}
for(i in 1:length(n_g)) {
w <- c(w, rep(t[i], n_g[i]))
}
return(w)
}
?unitroot
??unitroot
plot(dnorm(sd = 0.5))
plot(function(x){
dnorm(x, sd = 0.5)
})
plot(function(x){
dnorm(x, sd = 0.5)
}, from = -5, to = 5)
plot(function(x){
dnorm(x, sd = 0.5)
}, from = -2, to = 2)
m = 10
(rep(1, m) + 0.15 * (2 * rbinom(m, 1, 0.5) - 1)))
(rep(1, m) + 0.15 * (2 * rbinom(m, 1, 0.5) - 1))
rep(mu1, m),
rep(2, m)
genmu <- function(n, pi1, mu1,
posit_type = c("random", "fix"),
mu_type = 1:3){
m <- ceiling(n * pi1)
posit_type <- posit_type[1]
mu_type <- mu_type[1]
if (posit_type == "random"){
inds <- seq(1, n, floor(1 / pi1))[1:m]
} else if (posit_type == "fix"){
inds <- 1:m
}
mu <- rep(0, n)
mu[inds] <- switch(mu_type,
`1` = rep(mu1, m),
`2` = rep(mu1, m) + rnorm(m, sd = 0.5),
`3` = mu1 * (rep(1, m) + 0.15 * (2 * rbinom(m, 1, 0.5) - 1)))
}
genmu(10, 0.9, 2, "fix", 2)
genmu <- function(n, pi1, mu1,
posit_type = c("random", "fix"),
mu_type = 1:3){
m <- ceiling(n * pi1)
posit_type <- posit_type[1]
mu_type <- mu_type[1]
if (posit_type == "random"){
inds <- seq(1, n, floor(1 / pi1))[1:m]
} else if (posit_type == "fix"){
inds <- 1:m
}
mu <- rep(0, n)
mu[inds] <- switch(mu_type,
`1` = rep(mu1, m),
`2` = rep(mu1, m) + rnorm(m, sd = 0.5),
`3` = mu1 * (rep(1, m) + 0.15 * (2 * rbinom(m, 1, 0.5) - 1)))
return(mu)
}
genmu(10, 0.9, 2, "fix", 2)
genmu(10, 0.1, 2, "fix", 2)
genmu <- function(n, pi1, mu1,
posit_type = c("random", "fix"),
mu_type = 1:3){
m <- ceiling(n * pi1)
posit_type <- posit_type[1]
mu_type <- mu_type[1]
if (posit_type == "random"){
inds <- seq(1, n, floor(1 / pi1))[1:m]
} else if (posit_type == "fix"){
inds <- 1:m
}
mu <- rep(0, n)
mu[inds] <- switch(mu_type,
`1` = rep(mu1, m),
`2` = rep(mu1, m) + rnorm(m, sd = 0.3),
`3` = mu1 * (rep(1, m) + 0.15 * (2 * rbinom(m, 1, 0.5) - 1)))
return(mu)
}
genmu(10, 0.1, 2, "fix", 2)
genmu(10, 0.9, 2, "fix", 2)
plot(function(x){
dnorm(x, sd = 0.3)
}, from = -5, to = 5)
plot(function(x){
dnorm(x, sd = 0.3)
}, from = -2, to = 2)
#library("dbh")
source("dBH_utils.R")
source("utils.R")
genSigma <- function(n, rho = 0,
type = c("AR", "MA", "equi", "block", "iid"),
ifsqrt = F,
bsize = 10){
type <- type[1]
if (type == "AR"){
Sigma <- rho^(abs(outer(1:n, 1:n, "-")))
} else if (type == "MA"){
Sigma <- diag(n)
Sigma[cbind(1:(n-1), 2:n)] <- rho
Sigma[cbind(2:n, 1:(n-1))] <- rho
} else if (type == "equi"){
Sigma <- matrix(rho, n, n)
diag(Sigma) <- 1
} else if (type == "block"){
m <- floor(n / bsize)
if (n > bsize * m){
warning("n is not divisible by bsize")
}
Sigma <- diag(n)
blockSigma <- matrix(rho, bsize, bsize)
diag(blockSigma) <- 1
for (i in 1:m){
inds <- ((i - 1) * bsize + 1):(i * bsize)
Sigma[inds, inds] <- blockSigma
}
} else if (type == "iid"){
Sigma <- diag(n)
}
if(!ifsqrt) {
return(Sigma)
}
if (type == "iid") {
sqrtSigma <- Sigma
} else {
sqrtSigma <- with(eigen(Sigma), vectors %*% (sqrt(values) * t(vectors)))
}
return(list(Sigma = Sigma, sqrtSigma = sqrtSigma))
}
genmu <- function(n, pi1, mu1,
posit_type = c("random", "fix"),
mu_type = 1:3){
m <- ceiling(n * pi1)
posit_type <- posit_type[1]
mu_type <- mu_type[1]
if (posit_type == "random"){
inds <- seq(1, n, floor(1 / pi1))[1:m]
} else if (posit_type == "fix"){
inds <- 1:m
}
mu <- rep(0, n)
mu[inds] <- switch(mu_type,
`1` = rep(mu1, m),
`2` = rep(mu1, m) + rnorm(m, sd = 0.3),
`3` = mu1 * (rep(1, m) + 0.15 * (2 * rbinom(m, 1, 0.5) - 1)))
return(mu)
}
## automatically including BH procedure and BY procedure in the front.
gen_methods_dwBH <- function(gamma,
weight_type,
skip_dBH2){
expr_params <- expand.grid(
gamma = gamma,
weight_type = weight_type
)
# BH_methods <- sapply(weight_type, function(x){
#   weight_type <- paste0("(", x, ")")
#   tmp <- paste0("BH_", weight_type)
#   c(tmp, paste0(tmp, "_safe"))
# })
tmp <- "BH_(trivial)"
BH_methods <- c(tmp, paste0(tmp, "_safe"))
methods <- c(as.character(BH_methods))
dBH_methods <- apply(expr_params, 1, function(x){
if (is.na(x[1])){
gamma <- "safe"
} else {
gamma <- x[1]
}
weight_type <- paste0("(", x[2], ")")
method1 <- paste0("dwBH_", weight_type,
"_", gamma)
method2 <- paste0("dwBH_init_", weight_type,
"_", gamma)
c(method1, method2)
})
methods <- c(methods, as.character(dBH_methods))
if (!skip_dBH2){
dBH2_methods <- apply(expr_params, 1, function(x){
if (is.na(x[1])){
gamma <- "safe"
} else {
gamma <- x[1]
}
weight_type <- paste0("weighting(", x[2], ")")
method1 <- paste0("dwBH2_", weight_type,
"_", gamma)
method2 <- paste0("dwBH2_init_", weight_type,
"_", gamma)
c(method1, method2)
})
methods <- c(methods,
as.character(dBH2_methods))
}
return(methods)
}
gen_data <- function(n_g, mu1_g, pi1_g,
rho, Sigma_type,
sqrtSigma = NULL,
side,
nreps){
n <- sum(n_g)
ngroups <- length(n_g)
if (!(length(n_g) == length(mu1_g) & length(n_g) == length(pi1_g))){
stop("Each group should have its corresponding pi1 and mu1.")
}
if(is.null(sqrtSigma)) {
if(Sigma_type == "iid") {
sqrtSigma <- diag(n)
} else {
Sigma <- genSigma(n, rho, Sigma_type)
eigSigma <- eigen(Sigma)
sqrtSigma <- with(eigSigma, vectors %*% (sqrt(values) * t(vectors)))
}
}
mu <- c()
groups <- c()
for (j in 1: ngroups) {
mu <- c(mu, genmu(n_g[j], pi1_g[j], mu1_g[j]))
groups <- c(groups, rep(j , n_g[j]))
}
H0 <- mu == 0
zvals <- list()
for (i in 1:nreps){
if (side == "right"){
mu <- abs(mu)
} else if (side == "left"){
mu <- -abs(mu)
}
zvals[[i]] <- as.numeric(mu + sqrtSigma %*% rnorm(n))
# zvals[[i]] <- zvals[[i]] / sqrt(diag(Sigma))
# if (!is.null(Sigma) && any(diag(Sigma) != 1)){
#   Sigma <- cov2cor(Sigma)
# }
}
return(list(zvals = zvals, groups = groups, H0 = H0, sqrtSigma = sqrtSigma))
}
plot_results <- function(vals, methods, title,
cols, ltys, pchs,
ylim, ylab,
legend = TRUE,
cex.legend = 1.2,
alphas){
### Plot results for each method
alphalist <- alphas
nalphas <- length(alphas)
plot(0:1, 0:1, type = 'n',
xlim = range(alphalist), ylim = ylim,
xlab = expression(paste('Target FDR level ',alpha)),
ylab = ylab,
main = title, axes = FALSE)
axis(side = 1, at = c(0, 0.1, 0.2, 0.3))
axis(side = 2)
alpha_pt = 1:nalphas
for (i in 1:length(methods)){
points(alphalist, vals[i, ],
type = 'l', col = cols[i], lty = ltys[i])
points(alphalist, vals[i, alpha_pt],
col = cols[i], pch = pchs[i])
}
if (legend){
legend("topleft", methods,
col = cols, lty = ltys, pch = pchs,
seg.len = 3, cex = cex.legend, bty = "n")
}
}
plot_results(FDP, methods, titles[k], cols, ltys, pchs,
ylim = ylim, ylab = "FDR",
legend = T, cex.legend = 1.1,
alphas = c(0.05, 0.1, 0.2))
ylim <- c(0, 0.25)
plot_results(FDP, methods, titles[k], cols, ltys, pchs,
ylim = ylim, ylab = "FDR",
legend = T, cex.legend = 1.1,
alphas = c(0.05, 0.1, 0.2))
## Plots for simulation 1
methods <- gen_methods.wBH(c("trivial", "GBH", "optimal"), skip_BY = F)
wBH_postprocess <- function(res){
summaryres <- lapply(res, function(re){
FDR <- as.numeric(rowMeans(re$FDP))
FDR <- round(FDR, 4)
power <- as.numeric(rowMeans(re$power))
methods <- rownames(re$power)
df <- data.frame(method = methods,
FDR = FDR,
power = power)
df$alpha <- re$alpha
return(df)
})
nmethods <- length(methods)
nalphas <- length(methods)
FDR <- matrix(NA, nmethods, nalphas)
power <- matrix(NA, nmethods, nalphas)
df <- do.call(cbind, summaryres)
FDR <- df[, which(colnames(df)=="FDR")]
power <- df[, which(colnames(df)=="power")]
# methods <- rownames(df[,"method"])
# rownames(FDR) <- methods
# rownames(power) <- methods
return(list(FDR = FDR, power = power))
}
gen_methods.wBH <- function(weight_type, skip_BY){
expr_params <- expand.grid(
weight_type = weight_type
)
methods <- c()
wBH_methods <- apply(expr_params, 1, function(x){
weight_type <- x[1]
method1 <- paste0("wBH_(", weight_type,
")")
if (!skip_BY) {
method2 <- paste0("wBY_(", weight_type,
")")
} else {
method2 <- NULL
}
c(method1, method2)
})
methods <- c(as.character(wBH_methods))
return(methods)
}
## Plots for simulation 1
methods <- gen_methods.wBH(c("trivial", "GBH", "optimal"), skip_BY = F)
cols <- c('black', 'black','orange', 'orange', 'blue', 'blue')
ltys <- c(2,2,2,2,1,1)
pchs <- c(3,3,1,1,2,2)
ngroups <- c(2, 5, 10)
titles <- c(paste0(ngroups[1], " groups "), paste0(ngroups[2], " groups "),
paste0(ngroups[3], " groups "))
plot_results(FDP, methods, titles[k], cols, ltys, pchs,
ylim = ylim, ylab = "FDR",
legend = T, cex.legend = 1.1,
alphas = c(0.05, 0.1, 0.2))
plot_results(FDP, methods, titles, cols, ltys, pchs,
ylim = ylim, ylab = "FDR",
legend = T, cex.legend = 1.1,
alphas = c(0.05, 0.1, 0.2))
range(alphas)
alphas = c(0.05, 0.1, 0.2)
range(alphas)
plot_results <- function(vals, methods, title,
cols, ltys, pchs,
ylim, ylab,
legend = TRUE,
cex.legend = 1.2,
alphas){
### Plot results for each method
alphalist <- alphas
nalphas <- length(alphas)
plot(0:1, 0:1, type = 'n',
xlim = c(0, max(alphas)), ylim = ylim,
xlab = expression(paste('Target FDR level ',alpha)),
ylab = ylab,
main = title, axes = FALSE)
axis(side = 1, at = c(0, 0.1, 0.2, 0.3))
axis(side = 2)
alpha_pt = 1:nalphas
for (i in 1:length(methods)){
points(alphalist, vals[i, ],
type = 'l', col = cols[i], lty = ltys[i])
points(alphalist, vals[i, alpha_pt],
col = cols[i], pch = pchs[i])
}
if (legend){
legend("topleft", methods,
col = cols, lty = ltys, pch = pchs,
seg.len = 3, cex = cex.legend, bty = "n")
}
}
for (k in 1:3){
FDP <- wBH_oracle_inr_postres[[k]]$FDR
legend <- (k == 1)
plot_results(FDP, methods, titles[k], cols, ltys, pchs,
ylim = ylim, ylab = "FDR",
legend = T, cex.legend = 1.1,
alphas = c(0.05, 0.1, 0.2))
}
plot_results(FDP, methods, titles, cols, ltys, pchs,
ylim = ylim, ylab = "FDR",
legend = T, cex.legend = 1.1,
alphas = c(0.05, 0.1, 0.2))
