---
title: "two-group model"
author: "Mengqi LIn"
date: "9/4/2021"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(EbayesThresh)
library(locfdr)
source("dBH_utils.R")
```



## Settings 
### n_g : vector for number of hypothesis in each group. n_g = c(1000,2000)
### mu1_g : vector for mu1 in each group. mu1_g = c(1.5, 4)
### pi1_g : vector for pi1 in each group. pi1_g = c(0.1, 0.05)
```{r}
ng = 2
n_g = c(1000,1000) 
mu1_g = c(2, 2)
pi1_g = c(0.05, 0.1)
pi0_g = 1-pi1_g
alpha <- 0.05
```


## the lfdr.inverse function in each group
```{r}
## lfdr.inverse function
lfdr.inverse <- function(lfdr, pi0, mu1){
  1 - pnorm(1/mu1*log((pi0/lfdr - pi0)/(1-pi0)) + mu1/2)
}

## lfdr.inverse function in group1
lfdr.inverse1 <- function(lfdr) {
  lfdr.inverse(lfdr, pi0 = pi0_g[1], mu1 = mu1_g[1])
}

## lfdr.inverse function in group2
lfdr.inverse2 <- function(lfdr) {
  lfdr.inverse(lfdr, pi0 = pi0_g[2], mu1 = mu1_g[2])
}

## lfdr.inverse difference
diff_lfdr <- function(x) {
  lfdr.inverse2(x) - lfdr.inverse1(x)
}

## the point where they accord
for(i in seq(0.2, 0.25, 0.0001)){
  if(diff_lfdr(i)<0){
    phase_tran <- i
    break
  }
}
```


### the plots of lfdr.inverse function in each group:
```{r}
par(mar = c(4,4,4,4))
plot(lfdr.inverse1, type = "l")
plot(lfdr.inverse2, type = "l",col = "green", add = T)
```

```{r}
pi1_g
mu1_g
```


See lfdr.inverse in interval [0, 0.3]
```{r}
thr <- 0.1
plot(lfdr.inverse1, from = 0, to = thr, type = "l", lwd = 2)
plot(lfdr.inverse2, from = 0, to = thr, type = "l",col = "green", lwd = 2, add = T)
legend("topleft", legend = c(expression(paste(pi[1], ": 0.10, ", mu[1],": 1.5")),
                             expression(paste(pi[1], ": 0.05, ", mu[1],": 4.0"))),
       col = c("black", "green"), lwd = c(2, 2)
       )
abline(v = phase_tran, col = c("grey"), lwd = 2)
text(phase_tran, 0, phase_tran)
```


<!-- ```{r} -->
<!-- plot(diff_lfdr, from = 0, to = 0.3) -->
<!-- abline(h = 0, v = phase_tran, col = c("grey", "red"), lwd = c(1,2)) -->
<!-- text(phase_tran, diff_lfdr(0.3), phase_tran) -->
<!-- ``` -->





<!-- See lfdr.inverse in interval [0.3, 1] -->
<!-- ```{r} -->
<!-- plot(lfdr.inverse1, from = thr, to = 1, type = "l") -->
<!-- plot(lfdr.inverse2, from = thr, to = 1, type = "l",col = "green", add = T) -->
<!-- ``` -->

## mFDR function and mFDR plots versus alpha
```{r}
## to calculate mFDR, we need the cdf of nonnull p-values 
nonnull.cdf <- function(p, mu1) {
  pnorm(qnorm(1-p) - mu1,lower.tail = F)
}

## the mFDR function gives the mFDR, when we reject lfdr < c.
mFDR <- function(c, n_g, pi0_g, mu1_g) {
  V <- c()
  R <- c()
  for(i in 1:length(pi0_g)) {
    pi0 = pi0_g[i]
    mu1 = mu1_g[i]
    n = n_g[i]
    t = lfdr.inverse(c, pi0, mu1)
    V[i] = n*pi0*t
    R[i] = V[i] + n*(1-pi0)*nonnull.cdf(t, mu1)
  }
  return(sum(V)/sum(R))
}

## the mFDR function for our example
mFDR1 <- function(c) {
  mFDR(c, n_g = n_g, pi0_g = pi0_g, mu1_g = mu1_g)
}
mFDR1 <- Vectorize(mFDR1)
x = seq(0,1,0.01)
plot(x = seq(0,1,0.01), y = mFDR1(x), type = "l")
```

## Find lambda_alpha 
```{r}
lambda_alpha <- vecbinsolv(zf = alpha, fun = mFDR1 , tlo = 0, thi = 1, nits = 30)
lambda_alpha 

qnorm(lfdr.inverse1(lambda_alpha ), lower.tail = F)
vecbinsolv(zf = alpha, fun = lfdr.inverse1  , tlo = 0, thi = 1)
mFDR1(lambda_alpha)
```


## Compute oracle weights
```{r}

oracle_weights <- oracle.weights(alpha, n_g, pi0_g, mu1_g, pi0Est = F)
oracle_weights <- unique(oracle_weights)
oracle_weights
```

## Generate data based on our setting
```{r}


genmu <- function(n, pi1, mu1){
  m <- ceiling(n * pi1)
  mu <- rep(0, n)
  altmu <- rep(1, m)
  mu[1:m] <- mu1 * altmu
  mu
}

gen_data <- function(n_g, mu1_g, pi1_g, 
                     rho, Sigma_type,
                     side, 
                    nreps){
  n <- sum(n_g)
  ngroups <- length(n_g)
  Sigma <- diag(n)
  sqrtSigma <- Sigma
  mu <- c()
  groups <- c()
  for (j in 1: ngroups) {
    mu <- c(mu, genmu(n_g[j], pi1_g[j], mu1_g[j]))
    groups <- c(groups, rep(j , n_g[j]))
  }
  H0 <- mu == 0
    zvals <- list()
  for (i in 1:nreps){
    zvals[[i]] <- as.numeric(mu + sqrtSigma %*% rnorm(n))
  }
  return(list(zvals = zvals, groups = groups, H0 = H0, Sigma = Sigma))
}
nexp <- 100

set.seed(1)
data <- gen_data(n_g = n_g, mu1_g = mu1_g, pi1_g = pi1_g, 
                 rho = 0.8,
                  Sigma_type = "AR",
                  side = "right", 
                  nreps = nexp)
zvals <- data$zvals
groups <- data$groups
H0 <- data$H0
Sigma <- data$Sigma
```








## Calculate the adaptive optimal weights based on the package locfdr
```{r}
side <- "one"
adaptive_optimal_weights <- lapply(zvals, function(zv){
  adaptive_optimal.weights(groups, zv, alpha, side, type = "lin_exp", pi0Est = F)
})

#demo <- adaptive_optimal.weights(groups, zvals, alpha, side, type = "lin")
```

## plot the adaptive weights versus the oracle ones
```{r}
AOW_unique <- sapply(adaptive_optimal_weights, function(w){
  unique(w)
})
rowMeans(AOW_unique)

plot(c(Reduce(rbind, AOW_unique)), col = c(rep(c("black", "red"), length(AOW_unique)/2)))
abline(h = oracle_weights, col = c("black", "red"))
legend("topright", legend = c("group1", "group2"), col = c("black", "red"), lwd = c(1, 1))

```


```{r}
for(i in 1:nexp){
  print(i)
  print(unique(adaptive_optimal_weights[[i]]$weights))
}

unique(adaptive_optimal_weights[[27]]$weights)
```







```{r}
oracle_weights
thr_diff <- sapply(adaptive_optimal_weights, function(w){
  unique(w$thr_diff)
})
hist(thr_diff)
```




## hist the thr(lambda_alpha) of our adaptive procedure 
```{r}
est_thr <- sapply(adaptive_optimal_weights, function(w){
  unique(w$thr)
})
```


```{r}
hist(est_thr, main = expression(paste("Distribution of estimated_", lambda[alpha])), xlab = NULL)
abline(v = c(lambda_alpha, phase_tran), col = c("red", "blue"), lwd = 3)
legend("topleft", legend = c(expression(lambda[alpha]), "phase_trans"), col = c("red", "blue"), lwd = 3)
```

## plot the adaptive t_g versus the oracle ones
```{r}
AOW_tinit <- sapply(adaptive_optimal_weights, function(w){
  unique(w$t_g.init)
})
oracle_t <- c(lfdr.inverse1(lambda_alpha), lfdr.inverse2(lambda_alpha))

## plot the AOW_init_t versus its oracle t
plot(c(Reduce(rbind, AOW_tinit), oracle_t), col = c(rep(c("black", "green"), length(AOW_tinit)/2), c("blue", "red")))

## remove outliers and plot
AOW_tinit_clean <- AOW_tinit[, -ceiling(which(AOW_tinit > 0.5)/2)]
plot(c(Reduce(rbind, AOW_tinit_clean), oracle_t), col = c(rep(c("black", "green"), length(AOW_tinit_clean)/2), c("blue", "red")))
```





```{r}
zvals_lfdr_Res <- list()
zcut <- 2
ngroups <- 2
i <- 2
ind <- c(0, n_g)
zvals <- Z

zvals_lfdr_Res <- lapply(zvals, function(z){
  re <- lapply(1:ngroups, function(i){
    lfdr <- locfdr(z[(ind[i]+1):(ind[i]+ind[i+1])], nulltype = 0, plot = 0)$fdr
    index <- which(z[(ind[i]+1):(ind[i]+ind[i+1])] > zcut)
    zv <- z[index + ind[i]]
    o <- order(zv)
    zv <- zv[o]
    lfdr <- lfdr[index][o]
    return(list(zvals = zv, locfdr = lfdr))
  })
  return(re)
})
```


```{r}
lfdr_oracle <- function(z, pi0, mu1) {
  pi0*dnorm(z)/(pi0*dnorm(z)+(1-pi0)*dnorm(z, mean = mu1))
}
lfdr_oracle1 <- function(z){
  lfdr_oracle(z, pi0_g[1], mu1_g[1])
}
lfdr_oracle2 <- function(z){
  lfdr_oracle(z, pi0_g[2], mu1_g[2])
}

```



```{r}
plot(c(zcut, 5), c(0, 1), type = 'n',
     xlab = "zvals (group1)",
     ylab = "locfdr",
     main = "", axes = T)
nexp <- 100
for(i in 1:nexp) {
  points(zvals_lfdr_Res[[i]][[1]]$zvals, zvals_lfdr_Res[[i]][[1]]$locfdr, type = "b")
}
plot(lfdr_oracle1, from = zcut, to = 5, type = 'l', col = "red", add = T, lwd = 2)
legend("topright", "oracle_lfdr", col = "red", lwd = 2)
```



```{r}
plot(c(zcut, 5), c(0, 1), type = 'n',
     xlab = "zvals (group2)",
     ylab = "locfdr",
     main = "", axes = T)

for(i in 1:nexp) {
  points(zvals_lfdr_Res[[i]][[2]]$zvals, zvals_lfdr_Res[[i]][[2]]$locfdr, type = "b")
}
plot(lfdr_oracle2, from = zcut, to = 5, type = 'l', col = "red", add = T, lwd = 2)
legend("topright", "oracle_lfdr", col = "red", lwd = 2)
```






